/*
 * Copyright 2015 Emily Palmieri <silentfuzzle@gmail.com>
 * License: GNU GPL v3
 */
 
// Colors the links in a network given the user's history and current position
function LinkColorer() {
    this.linkDictionary = new Object();
    this.minNodeID = -1;
    
    ///////////////////////////////////////////////////////////////////////////
    // PATH SEARCH PREPARATION
    ///////////////////////////////////////////////////////////////////////////
    
    // Set the section with the smallest page number
    // nodeID - The first page/ID of the section to check
    this.updateMinNodeID = function(nodeID) {
        if (this.minNodeID == -1 || nodeID < this.minNodeID) {
            this.minNodeID = nodeID;
        }
    };
    
    // Add a node to a dictionary of links between nodes
    // linkDictionary - The dictionary of links
    // nodeID - The ID of the node to add
    this.addNode = function(linkDictionary, nodeID) {
        var node;
        if (linkDictionary.hasOwnProperty(nodeID)) {
            node = linkDictionary[nodeID];
        }
        else {
            node = new NetworkNode(nodeID);
            linkDictionary[nodeID] = node;
        }
        
        return node;
    };
    
    // Builds a dictionary of links between nodes from a list
    // link - A list of links generated by d3
    this.buildLinkDictionary = function(link) {
        var tempDictionary = new Object();
        var addNodeMethod = this.addNode;
        
        link.each(function(d) {
            // Store the linked nodes
            var sourceID = parseFloat(d.source.id);
            var targetID = parseFloat(d.target.id);
            var target = addNodeMethod(tempDictionary, targetID);
            var source = addNodeMethod(tempDictionary, sourceID);
            
            // Store the link between the two nodes
            var linkInfo = new NetworkLink(source, target, this);
            target.inLinks.push(linkInfo);
            source.outLinks.push(linkInfo);
        });
        
        // Store the dictionary of links
        this.linkDictionary = tempDictionary;
        if (this.linkDictionary.hasOwnProperty(this.minNodeID)) {
            // Calculate the minimum distance and path to the minimum node from all nodes
            this.linkDictionary[this.minNodeID].followOutLinks(new Crumb());
        }
    };
    
    ///////////////////////////////////////////////////////////////////////////
    // GET PATH FROM HISTORY
    ///////////////////////////////////////////////////////////////////////////
    
    // Return the links from a position to another position in history
    // endNodeID - The position in history to stop at
    // colorInfo - An object containing the links found and the links left to search
    this.colorLinksFromRecentHistory = function(endNodeID, colorInfo) {
        var currHistoryNode = colorInfo.lastHistory;
        
        var currNodeID = currHistoryNode.pos;
        if (currNodeID != endNodeID) {
            var currNode = this.linkDictionary[currNodeID];
            var prevHistoryNode = currHistoryNode.prev;
            var currLink = currNode.getLink(prevHistoryNode.pos);
            colorInfo.lastHistory = prevHistoryNode;
            colorInfo.addLink(currLink);
            colorInfo = this.colorLinksFromRecentHistory(endNodeID, colorInfo);
        }
        
        return colorInfo;
    };
    
    // Return the links from the user's current position to their last position in history
    // startNodeID - The ID of the user's current position
    // colorInfo - An object containing the links found and the links left to search
    this.colorLinksFromAllHistory = function(startNodeID, colorInfo) {
        var currHistoryNode = colorInfo.lastHistory;
        
        if (currHistoryNode != null) {
            var currNodeID = currHistoryNode.pos;
            if (colorInfo.contains(currNodeID)) {
                colorInfo.reset(startNodeID);
                colorInfo = this.colorLinksFromRecentHistory(currNodeID, 
                        colorInfo);
            }
            else {
                if (this.linkDictionary.hasOwnProperty(currNodeID)) {
                    var currNode = this.linkDictionary[currNodeID];
                    var prevHistoryNode = currHistoryNode.prev;
                    if (prevHistoryNode != null) {
                        var currLink = currNode.getLink(prevHistoryNode.pos);
                        if (currLink != null) {
                            colorInfo.lastHistory = prevHistoryNode;
                            colorInfo.addLink(currLink);
                            colorInfo = this.colorLinksFromAllHistory(
                                    startNodeID, colorInfo);
                        }
                    }
                }
            }
        }
        
        return colorInfo;
    };
    
    ///////////////////////////////////////////////////////////////////////////
    // GET PATH FROM DISTANCE
    ///////////////////////////////////////////////////////////////////////////
    
    this.colorLinksFromMinNodeDistance = function(currNodeID, historicLinks) {
        var crumb = this.linkDictionary[currNodeID].crumb;
        var endpoints = this.mergeEndPointLists(historicLinks, crumb);
        
        return endpoints;
    };
    
    this.colorLinksFromCurrNodeDistance = function(currNodeID, historicLinks) {
        this.linkDictionary[currNodeID].clearSearch();
        this.linkDictionary[this.minNodeID].clearSearch();

        this.linkDictionary[currNodeID].followInLinks(this.minNodeID, 
                new Crumb());
        var crumb = this.linkDictionary[this.minNodeID].crumb;
        
        var endpoints = this.mergeEndPointLists(historicLinks, crumb);        
        return endpoints;
    };
    
    this.colorLinksFromDistance = this.colorLinksFromMinNodeDistance;
    
    ///////////////////////////////////////////////////////////////////////////
    // GET PATH FROM BEGINNING TO POSITION
    ///////////////////////////////////////////////////////////////////////////
    
    this.mergeEndPointLists = function(historicLinks, crumb) {
        var endpoints = historicLinks.endPoints;
        var restart = false;
        var link = crumb.link;
        var historyOnDistance = [];
        while (link != null) {
            var sourceID = link.source.nodeID;
            var targetID = link.target.nodeID;
            
            var sourceOnPath = historicLinks.contains(sourceID);
            var targetOnPath = historicLinks.contains(targetID);
            if (targetID != crumb.link.target.nodeID && 
                    (sourceOnPath || targetOnPath)) {
                link = null;
                restart = true;
                if (sourceOnPath) {
                    historyOnDistance.push(sourceID);
                }
                if (targetOnPath) {
                    historyOnDistance.push(targetID);
                }
            }
            else {
                endpoints.push(link.linkSVG);
                var tempLink = link.source.crumb.link;
                if (tempLink != null && 
                        tempLink.source.nodeID == link.source.nodeID) {
                    link = link.target.crumb.link;
                }
                else {
                    link = tempLink;
                }
            }
        }
        
        if (restart) {
            var minID = historyOnDistance[0];
            var minDistance = this.linkDictionary[minID].crumb.length;
            for (var n = 1; n < historyOnDistance.length; n++) {
                var currNodeID = historyOnDistance[n];
                var currDistance = this.linkDictionary[currNodeID].crumb.length;
                if (currDistance < minDistance) {
                    minID = currNodeID;
                    minDistance = currDistance;
                }
            }
            
            var historyNode = historicLinks.lastHistory;
            historicLinks = new HistoricLinks([], historyNode);
            var colorInfo = this.colorLinksFromRecentHistory(minID, 
                    historicLinks);
                    
            var lastNodeID = colorInfo.lastHistory.pos;
            historicLinks = new HistoricLinks(colorInfo.endPoints, historyNode);
            endpoints = this.colorLinksFromDistance(lastNodeID, historicLinks);
        }
        
        return endpoints;
    };
    
    this.getPathToColor = function(historyNode) {
        var endpoints = [];
        
        var historicLinks = new HistoricLinks([], historyNode);
        var colorInfo = this.colorLinksFromAllHistory(historyNode.pos, 
                historicLinks);
        endpoints = colorInfo.endPoints;
        
        if (colorInfo.lastHistory != null) {
            var currNodeID = colorInfo.lastHistory.pos;
            if (currNodeID != this.minNodeID &&
                    this.linkDictionary.hasOwnProperty(this.minNodeID) && 
                    this.linkDictionary.hasOwnProperty(currNodeID)) {
                colorInfo.lastHistory = historyNode;
                endpoints = this.colorLinksFromDistance(currNodeID, colorInfo);
            }
        }
        
        return endpoints;
    };
}
