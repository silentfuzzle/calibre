  <!DOCTYPE html> 
  <meta charset="utf-8">
  <body> 
 <style> 
.link {
fill: none;
stroke: #666;
opacity: 0.6;
}

.node circle { 
stroke: #fff; 
opacity: 0.6;
stroke-width: 1.5px; 
}

text { 
opacity: 1;
pointer-events: none; 
}

.btnText {
font: 10px serif;
opacity: 1;
}
</style> 

<div id="controls">
    <p>Position nodes: 
        <button onclick="toggleZoomListener()"><text class="btnText">Off</text></button>
    </p>
</div>

<div id="networkContainer"></div>

<script src=d3.v3.min.js></script>

<script> 
/*
 * Copyright 2014 Emily Palmieri <silentfuzzle@gmail.com>
 * License: GNU GPL v3
 */

//d3.json("eBookGraph.json", dataLoaded)

///////////////////////////////////////////////////////////////////////////////
//LAYOUT AND BEHAVIOR VARIABLES
///////////////////////////////////////////////////////////////////////////////

var width = 500,
    height = 500;

var textDefaultOpacity = 0.6;
var textOffset = 4;
var textDefaultSize = 7;
var textMaxSize = 17.5;

var nodeDefaultRadius = 8;
var nodeMaxRadius = 16;

var straightLinks = true;
var linkDefaultWidth = 1.5;
var linkMaxWidth = 5;
    
///////////////////////////////////////////////////////////////////////////////
//SETUP
///////////////////////////////////////////////////////////////////////////////

var vis;
var force;
var currPage = -1;
var node = 0;
var link;
  
// Set the viewer window to fill the TOC panel
var svg = d3.select("div#networkContainer")
    .append("svg")
      .attr({
        "width": "100%",
        "height": "100%"
      })
      .attr("preserveAspectRatio", "xMidYMid meet")
      .attr("pointer-events", "all");

// Controls the zoom and pan functions initiated by the user
var zoomListening = true;
var zoomListener = d3.behavior.zoom()
  .scaleExtent([0.1, 3])
  .on("zoom", redraw);

///////////////////////////////////////////////////////////////////////////////
//CALLED FROM PYTHON
///////////////////////////////////////////////////////////////////////////////

// Display a network from passed JSON data
// data (string) - json code
// pageNum (float) - the number of the first page of the section the user is currently viewing
function dataLoaded(data, pageNum) {
    var links = data.links;
    var nodes = data.nodes;
    
    var nodeDictionary = new Object();
    if (node != 0) {
        // The user has created a new link, prepare to reload the network
        force.stop();
        
        // Save the current node positions in a dictionary
        node.each(function(d) {
            var nodeInfo = [];
            nodeInfo[0] = d.x;
            nodeInfo[1] = d.y;
            nodeInfo[2] = d.fixed;
            nodeDictionary[d.id] = nodeInfo;
        });
        
        // Set the initial node positions to the saved positions
        nodes.forEach(function(n) {
            var x = nodeDictionary[n.id][0];
            var y = nodeDictionary[n.id][1];
            n.x = x;
            n.y = y;
            n.r = nodeDefaultRadius;
            n.fixed = nodeDictionary[n.id][2];
        });
    }
    else {
        // Set the default value for nodes when the network is initialized for the first time
        nodes.forEach(function(n) {
            n.r = nodeDefaultRadius;
            n.fixed = false;
        });
    }

    // Set the type of network to display and its parameters
    force = d3.layout.force() 
        .nodes(nodes) 
        .links(links) 
        .size([width, height]) 
        .linkDistance(50) 
        .charge(-100) 
        .on("tick", tick)
        .start();
        
    // Clear any old network data from previous renderings
    d3.selectAll("svg > *").remove();

    // Reset the variables for displaying links as arrows
    // .append("path") - creates a triangle shape to place at the end of an arrow
    // markerUnits - prevents the arrow from resizing with the stroke-width of a link
    svg.append("defs").selectAll("marker")
        .data(["suit"])
      .enter().append("marker")
        .attr("id", function(d) { return d; })
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 10)
        .attr("refY", 0)
        .attr("markerWidth", 10)
        .attr("markerHeight", 10)
        .attr("orient", "auto")
        .attr("markerUnits", "userSpaceOnUse")
      .append("path")
        .attr("d", "M0,-5L10,0L0,5");
    
    // This group contains all elements of the network
    // Allows users to zoom and pan by manipulating the svg
    vis = svg.append('svg:g');
    
    // Create an object that stores all links added to the network
    // "marker-end" - associates a triangle with a link to create a directed arrow
    // .style - used for resizing the links as the user zooms in or out of the network
    // .attr("class", "link") - sets the .link css attributes to links
    link = vis.selectAll("path")
        .data(force.links())
      .enter().append("g")
        .attr("class", "link")
        .attr("marker-end", "url(#suit)");
    
    // Make path attributes accessible for animation/modification
    link.append("path")
        .style("stroke-width", linkDefaultWidth + "px"); 
        
    // Create an object that stores all the nodes added to the network
    // .attr("class", "node") - sets the .node circle attributes to node circles
    node = vis.selectAll(".node") 
        .data(force.nodes()) 
      .enter().append("g") 
        .attr("class", "node") 
        .attr("page", function(d) { return d.id; })
        .attr("x", function(d) { return d.x; })
        .attr("y", function(d) { return d.y; })
        .on("mouseover", mouseover) 
        .on("mouseout", mouseout) 
        .on("click", click)
        .on("dblclick", dblclick); 

    // Set the appearance of the node to be a circle
    node.append("circle") 
        .attr("r", function(d) { return d.r; });

    // Set the text appearing next to the node and other data the node stores
    node.append("text") 
        .attr("x", nodeDefaultRadius + textOffset) 
        .attr("dy", ".35em") 
        .style("fill", "#000000")
        .text(function(d) { return d.title; });
    
    // Wrap the text of long titles
    node.selectAll("text")
        .call(wrap, 100);
      
    // Set the opacity of wrapped text
    node.selectAll("text")
        .selectAll('tspan')
        .style("opacity", textDefaultOpacity);
    
    // Set the color of the nodes
    changePage(pageNum);
    
    // Make sure the display is set to the current scale and location
    zoomListener.scale(zoomListener.scale());
    zoomListener.translate(zoomListener.translate());
    zoomListener.event(vis);
    setZoomListener();
}

// Set the color of the nodes
// pageNum (float) - the number of the first page of the section the user is currently viewing
function changePage(pageNum) {
    currPage = pageNum;
    node.select("circle").style("fill", fillNode);
}

///////////////////////////////////////////////////////////////////////////////
//DRAW METHODS
///////////////////////////////////////////////////////////////////////////////

// Wraps the text labeling each node
// text - the text attribute selected from all nodes
// width - the maximum width of a label
function wrap(text, width) {
    text.each(function() {
        var text = d3.select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            y = 0,
            x = nodeDefaultRadius + textOffset,
            dy = parseFloat(text.attr("dy")),
            tspan = text.text(null).append("tspan")
                .attr("x", x)
                .attr("y", y)
                .attr("dy", dy + "em")
                .style("font", textDefaultSize + "px serif");
        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                lineNumber = lineNumber + 1;
                tspan = text.append("tspan")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", lineNumber * lineHeight + dy + "em")
                    .style("font", textDefaultSize + "px serif")
                    .text(word);
            }
        }
    });
}

// Color a node in the network
// d - node data
function fillNode(d) {
    if (d.id == currPage) { 
        // Color the node of the section the user is currently viewing a different color
        return "#555555"; 
    } 
    else { 
        return "#3182bd"; 
    }
}

// Animates the growing of a node's radius
// d - node data
function growRadius(d) {
    // Create a function that returns the radius at time t
    var interpolation = d3.interpolateNumber(d.r, nodeMaxRadius);
    
    // Get the links associated with the node
    var nodeLinks = getUpdateLinks(d.id);
    
    // Animate the node and its associated links
    return function(t) {
        d.r = interpolation(t);
        nodeLinks.forEach(updateLinkPath);
        
        return d.r;
    }
}

// Animates the shrinking of a node's radius
// d - node data
function shrinkRadius(d) {
    // Create a function that returns the radius at time t
    var interpolation = d3.interpolateNumber(d.r, nodeDefaultRadius);
    
    // Get the links associated with the node
    var nodeLinks = getUpdateLinks(d.id);
    
    // Animate the node and its associated links
    return function(t) {
        d.r = interpolation(t);
        nodeLinks.forEach(updateLinkPath);
        
        return d.r;
    }
}

// Animate a link so that's end points remain at the edge of an animated node
// link - a link sgv element
function updateLinkPath(link) {
    d3.select(link).select("path").attr("d", drawCurve);
}

// Draws a directed link between nodes
// d - a link object pulled from the svg
function drawCurve(d) {
    var sourceX = d.source.x;
    var sourceY = d.source.y;
    var targetX = d.target.x;
    var targetY = d.target.y;
    
    var theta = Math.atan((targetX - sourceX) / (targetY - sourceY));
    var phi = Math.atan((targetY - sourceY) / (targetX - sourceX));
    
    var sinTheta = d.source.r * Math.sin(theta);
    var cosTheta = d.source.r * Math.cos(theta);
    var sinPhi = d.target.r * Math.sin(phi);
    var cosPhi = d.target.r * Math.cos(phi);
    
    // Set the position of the link's end point at the source node
    // such that it is on the edge closest to the target node
    if (d.target.y > d.source.y) {
        sourceX = sourceX + sinTheta;
        sourceY = sourceY + cosTheta;
    }
    else {
        sourceX = sourceX - sinTheta;
        sourceY = sourceY - cosTheta;
    }
    
    // Set the position of the link's end point at the target node
    // such that it is on the edge closest to the source node
    if (d.source.x > d.target.x) {
        targetX = targetX + cosPhi;
        targetY = targetY + sinPhi;    
    }
    else {
        targetX = targetX - cosPhi;
        targetY = targetY - sinPhi;   
    }
    
    if (straightLinks) {
        // Draw a line between the two calculated points
        // M - move to position
        // L - draw a line from current position to end position
        return "M" + sourceX + "," + sourceY + "L" + targetX + "," + targetY;
    }
    else {
        // Draw an arc between the two calculated points
        // M - move to position
        // A - draw arc from current position to end position
        //  about an ellipse with x- and y-radius (dr, dr)
        //  rotated 0 radians relative to the current coordinate system
        var dx = targetX - sourceX,
            dy = targetY - sourceY,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" + sourceX + "," + sourceY + 
            "A" + dr + "," + dr + " 0 0,1 " + targetX + "," + targetY;
    }
    // See svg "path" attribute for more information
}
    
///////////////////////////////////////////////////////////////////////////////
//POSITION METHODS
///////////////////////////////////////////////////////////////////////////////

// Animates the force-directed network
function tick() { 
    link.select("path").attr("d", drawCurve);
    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    
    // Update references to the node's position
    node.attr("x", function(d) { return d.x; })
        .attr("y", function(d) { return d.y; });
}

// Scales and pans the network as specified by the user
function redraw() {
  vis.attr("transform",
      "translate(" + d3.event.translate + ")"
      + " scale(" + d3.event.scale + ")");
}

// Centers a node on the screen
// source - an object containing a node svg object
function centerNode(source) {
    scale = zoomListener.scale();
    x1 = d3.select(source).attr("x");
    y1 = d3.select(source).attr("y");
    
    // Center the node at 0 on the svg
    x2 = (width / 2 - x1);
    y2 = (height / 2 - y1);
    
    // Get the screen position of the node at the center of the svg
    var sPos = getScreenCoords(x1, y1, [x2, y2], scale);
    
    // Center the node on the display
    x2 = x2 + (width / 2 - sPos[0]);
    y2 = y2 + (height / 2 - sPos[1]);
    
    // Apply the transformation to the display
    zoomListener.scale(scale);
    zoomListener.translate([x2, y2]);
    zoomListener.event(vis);
}

// Returns the position of the center of a node on the screen
// x - the x-position of a node on the svg
// y - the y-position of a node on the svg
// translate - the transformation required to center the node on the svg
// scale - the current scale of the svg
function getScreenCoords(x, y, translate, scale) {
    var xn = translate[0] + x*scale;
    var yn = translate[1] + y*scale;
    
    return [xn, yn];
}

///////////////////////////////////////////////////////////////////////////////
//EVENTS
///////////////////////////////////////////////////////////////////////////////

// Calls Python to send the user to the section corresponding to the node clicked in the viewer
function click() {
    if (zoomListening) {
        centerNode(this);
        
        // Get the first page number of the section from the node that was clicked
        pageNum = d3.select(this).attr("page");
        
        // Call the Python code to change pages
        container.change_page(pageNum);
    }
    else {
        d3.select(this).attr("fixed", function(d) { d.fixed = true; return d.fixed; });
    }
}

function mouseover() {
    d3.select(this).select("circle").transition() 
        .duration(750) 
        .attrTween("r", growRadius);
        
    d3.select(this).select("text").transition()
        .duration(750)
        .selectAll('tspan').attr("x", nodeMaxRadius + textOffset)
        .attr("y", 0.1)
        .style("opacity", 1)
        .style("font", textMaxSize + "px serif");
        
    // Emphasize links pointing away from the current node
    var page = d3.select(this).attr("page");
    var nodeLinks = getUpdateLinks(page);
    nodeLinks.forEach(function(link) {
        d3.select(link).select("path").transition()
            .duration(750)
            .style("stroke-width", linkMaxWidth + "px");
    });
} 

function mouseout() { 
    d3.select(this).select("circle").transition() 
        .duration(750) 
        .attrTween("r", shrinkRadius);
        
    d3.select(this).select("text").transition()
        .duration(750)
        .selectAll('tspan').attr("x", nodeDefaultRadius + textOffset)
        .attr("y", 0)
        .style("opacity", textDefaultOpacity)
        .style("font", textDefaultSize + "px serif");
        
    // Demphasize links pointing away from the current node
    var page = d3.select(this).attr("page");
    var nodeLinks = getUpdateLinks(page);
    nodeLinks.forEach(function(link) {
        d3.select(link).select("path").transition()
            .duration(750)
            .style("stroke-width", linkDefaultWidth + "px");
    });
} 

// action to take on mouse double click
function dblclick() {
    d3.select(this).attr("fixed", function(d) { d.fixed = false; return d.fixed; });
}

// Flips the control scheme between positioning nodes and navigating nodes
function toggleZoomListener() {
    if (zoomListening) {
        zoomListening = false;
    }
    else {
        zoomListening = true;
    }
    setZoomListener();
}

///////////////////////////////////////////////////////////////////////////////
//MISCELLANEOUS
///////////////////////////////////////////////////////////////////////////////

// Returns a list of link svg elements associated with a node with id page
// page - the id of a node
function getUpdateLinks(page) {
    var nodeLinks = [];
    link.each(function(d) {
        if (d.source.id == page || d.target.id == page) {
            nodeLinks.push(this);
        }
    });
    
    return nodeLinks;
}

// Sets the controls scheme based on the selected mode
function setZoomListener() {
    if (zoomListening) {
        addZoomListener();
    }
    else {
        removeZoomListener();
    }
}

// Sets the control scheme to positioning nodes
function removeZoomListener() {
    svg.on("mousedown.zoom", null);
    svg.on("mousemove.zoom", null);
    svg.on("dblclick.zoom", null);
    svg.on("touchstart.zoom", null);
    svg.on("wheel.zoom", null);
    svg.on("mousewheel.zoom", null);
    svg.on("MozMousePixelScroll.zoom", null);
    node.call(force.drag);
    d3.select("div#controls button").select("text").text("On");
}

// Sets the control scheme to navigating nodes
function addZoomListener() {
    node.on('mousedown.drag', null);
    node.on('touchstart.drag', null);
    zoomListener(svg);
    d3.select("div#controls button").select("text").text("Off");
}

</script>
 </body>